<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600646 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="481"/>
<h1>MeshRepair notes</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/4/2 16:50</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/4/2 18:15</i></td></tr>
<tr><td><b>作者：</b></td><td><i>csyhping</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><ul><li><div><span style="font-weight: bold;">整体思路</span></div></li></ul><div>           文件格式转换-&gt;读取文件-&gt;检测并删除孤立点(unreferenced vertices or isolate vertices)-&gt;获取连通分支(components)-&gt;根据最大连通分支(max components)删除其余分支(small components)</div><ul><li><div><span style="font-weight: bold;">代码整理与记录</span></div></li></ul><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">1. <span style="font-weight: bold;">格式转换(convert mesh format)</span></span><br/></div><div><span style="font-weight: bold;"><br/></span></div><div>mesh的格式有.off/.ply/.obj等等，在实验过程中发现，libigl中的</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>igl::readPLY();</div></div><div>           </div><div>在读取.ply文件时会出现Fatal Error，并且没有找到好的解决方法，于是决定在一切处理之前，先统一将文件格式转换成.off，主要用到的函数是</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>igl::write_triangle_mesh()</div><div>igl::read_triangle_mesh()</div><div>igl::writeOFF()</div></div><div>           </div><div>即读取的时候无视掉文件格式问题，只提取mesh的vertex和face信息，并写成.off格式文件</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">2. <span style="font-weight: bold;">文件读取(load_file_off())</span></span></div><div><span style="font-weight: bold;"><br/></span></div><div>这部分主要是根据用户输入的参数读取mesh文件，如果参数数量不足，显示USAGE信息，目前提供两个可选参数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">-c: 对不同的components上色</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">-o: 启用igl::opengl::glfw::Viewer显示处理后的mesh</span></div></div><div>      </div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">3. <span style="font-weight: bold;">删除孤立点(delete_iso_v)</span></span></div><div><span style="font-weight: bold;"><br/></span></div><div>孤立点的定义一般是isolate vertex或者(在Libigl中)unreferenced vertex，检测并处理孤立点的函数是</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>igl::remove_unreferenced(V, F, NV, NF, IM);</div></div><div>           </div><div>这个函数会在输入的mesh(V, F)中检测孤立点，如果存在则删除并更新(V, F)到(NV, NF)中</div><div>         </div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">4. <span style="font-weight: bold;">获取连通分支(get_components)</span></span></div><div><span style="font-weight: bold;"><br/></span></div><div>连通分支可以用来寻找mesh中相互独立的部分，在本次mesh处理中，保留最大连通分支(max components)，将其余小的连通分支(small components)移除，这是因为本</div><div>次处理中的牙齿mesh文件，只有最大的连通分支是牙齿本体，其余分支均是需要删               除的部分。根据Libigl，连通分支存在两种，一种是顶点连通分支(vertex components)，一种是面片连通分支(face components)，检测两种连通分支的函数是</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>igl::facet_components(F, CF) # Eigen::VectorXi CF</div><div>igl::vertex_components(F, CV) # Eigen::VectorXi CV</div></div><div>             </div><div>其中CF, CV中存储的都是每个vertex/face所在的连通分支的序号，比如mesh中只有一个连通分支，那么CF/CV中每个元素都是0。根据CF/CV中不同元素的个数，得到当前mesh中存在的连通分支数max_f_size/max_v_size(元素从0开始，记得+1)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int max_f_size = CF.maxCoeff();</div><div>int max_v_size = CV.maxCoeff();</div></div><div><br/></div><div>这里设定5个辅助记录的Matrix/Vector，分别是</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>VectorXi ACF # all face components, ACF(i)记录的是第i个face components的数量</div><div>VectorXi ACV # all vertex components, ACV(i)记录的是第i个vertex components的数量</div><div>MatrixXi CPF # face components position, CPF(i, j)记录的是第i个components中face的情况，eg. components 0: F0, F1, F2, ...</div><div>MatrixXi CPV # vertex components position, CPV(i, j)记录的是第i个components中vertex的情况，eg. components 0: V1, V2, V3...</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">VectorXi Pos_flag # 用来控制在CPF/CPV的每一行写入数据的位置</span></div></div><div><br/></div><div>首先遍历CF，并将每个components的总数量计入ACF中</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ACF.setZero() #将ACF初始化为0</div><div>for (int i = 0;i&lt;CF.rows();i++){</div><div><span>    ACF(CF(i)) += 1 ;</span><br/></div><div>}</div></div><div><br/></div><div>根据max components的数量设定CPF/Pos_flag的大小，并初始化为0，遍历CF，在CPF中记录每个components包含face的情况</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (int i = 0;i&lt;CF.rows();i++){</div><div><span>    CPF(CF(i), Pos_flag(CF(i))) = i;</span><br/></div><div><span><span>    Pos_flag(CF(i)) += 1;</span><br/></span></div><div>}</div></div><div><br/></div><div>遍历CV，并将每个components的总数量计入ACV中</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ACV.setZero() #将ACV初始化为0</div><div>for (int i = 0;i&lt;CV.rows();i++){</div><div>    ACV(CV(i)) += 1;</div><div>}</div></div><div><br/></div><div>根据max components的数量设定CPV/Pos_flag的大小，并初始化为0，遍历CV，在CPV中记录每个components包含vertex的情况</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (int i = 0;i&lt;CV.rows();i++){</div><div>    CPV(CV(i), Pos_flag(CV(i))) = i;</div><div>    Pos_flag(CV(i)) += 1;</div><div>}</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">4.1. <b>设定颜色(set_color_per_component())</b></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b><br/></b></span></div><div>给不同的component用不同的颜色显示，这样可以更直观的观察不同components的情况，在实验过程中这一步主要是为了获取直观结果方便调试，颜色信息记录在</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>MatrixXd color_per_face</div></div><div><br/></div><div>首先根据CF中每个face所在components的值，建立transfer funtion获取不同的color</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>igl::jet(CF.col(0), true, color_per_face);</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">...</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">viewer.data().set_colors(color_per_face)</span></div></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">5. <b>保留最大连通分支删除小的连通分支(delete_isolate_Triangles())</b></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b><br/></b></span></div><div>在本次实验中，只保留最大的连通分支，其余分支均要删除，在其他应用场景中，应该设定components_size_threshold来决定删除哪些分支。在前面经过处理后的ACF和ACV中定位到最大连通分支的id，这里用到Eigen中的Index功能来定位</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>VectorXi::Index maxRow_F, maxCol_F, maxRow_V, maxCol_V # 即使col只有一列，也需要设定一个参数</div><div>int max_components_f = ACF.maxCoeff(&amp;maxRow_F, &amp;maxCol_F) # 这样maxRow_F中记录的就是max components所在的行数(也就是所谓的components id)</div></div><div><br/></div><div>接下来需要在初始mesh的V/F中把max components所对应的V和F提取出来，这里用到的是</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>igl::slice(A, R, C, B) # R是记录row id的vector, C是记录col id的vector，这样会根据RC在A中提取行列到B中</div></div><div><br/></div><div>因为在mesh文件中，vertex是用坐标信息(x, y, z)记录的，但是在提取过程中，同一个vertex在初始V和V_max中所在行数可能不同，所以要记录其位置变化，以便后面vertex和face在max component mesh中位置的重定位。对于顶点的抽取和重定位的过程如下</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (int i = 0;i&lt;ACV(maxRow_V);i++){</div><div><span>    if (i &gt; 0 &amp;&amp; CPV(maxRow_V, i) == 0){</span><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span>    </span><span>    </span><span>    // 因为CPV是根据max components数量初始化的size并且所有元素初始化为0，出了第一个元素允许为0外，在同一行后面再遇到0即代表边界</span><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    </span><span>    </span><span>    break;</span><br/></span></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    </span><span>    </span>}</span></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    </span><span>    else{</span><br/></span></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    </span><span>    </span><span>    RV(i) = CPV(maxRow_V, i);</span><br/></span></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    </span><span>    </span><span>    V_Change(RV(i)) = CPV(maxRow_V, i) - i; #eg. if V3-&gt;V0, records the change 3-0=3</span><br/></span></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span>    </span><span>    </span>}</span></div><div>}</div></div><div><br/></div><div>用slice函数从V中抽取行列到V_max中</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>igl::slice(V, RV, C, V_max);</div></div><div><br/></div><div>对于F，抽取max components中F的位置信息</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (int i = 0;i&lt;ACF(maxRow_F);i++){</div><div><span>    if(i &gt; 0 &amp;&amp; CPF(maxRow_F, i) == 0){</span><br/></div><div><span>    <span>    break; # 同上，判断边界</span></span></div><div><span><span><span>    </span>}</span><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span>    </span><span>    else{</span><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    </span><span>    </span><span>    FV(i) = CPF(maxRow_F, i);</span><br/></span></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    </span><span>    }</span><br/></span></span></div><div>}</div><div><br/></div><div>igl::slice(F, FV, C, F_max);</div></div><div><br/></div><div>根据V_Change中记录的vertex位移信息，重新定位对应的F坐标，因为F是用V的id代表的，eg. F1 = (V1, V2, V3)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (int i = 0;i&lt;F_max.rows();i++){</div><div><span>    for(int j = 0;j&lt;F_max.cols();j++){</span><br/></div><div><span><span>    </span><span>    F_max(i, j) -= V_Change(F_max(i, j));</span><br/></span></div><div><span><span>    }</span><br/></span></div><div>}</div></div><div><br/></div><div>至此，max components抽取完成，生成新文件</div></span>
</div></body></html> 